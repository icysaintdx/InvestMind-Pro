# InvestMind Pro - 核心逻辑与算法文档（第2部分）

> **主题**: 多智能体辩论机制、风险评估与仓位管理  
> **创建日期**: 2025-12-05

---

## 一、多智能体辩论机制

### 1.1 研究辩论（多空对决）

**文件位置**: `backend/api/debate_api.py`

#### 辩论流程

```
第1轮: 看涨研究员 → 看跌研究员
第2轮: 看涨研究员(基于看跌观点) → 看跌研究员(基于看涨观点)
第3轮: 看涨研究员 → 看跌研究员
...
最终: 投资研究经理综合决策
```

#### 观点强度计算

```python
def _calculate_view_strength(views: List[Dict]) -> float:
    """
    观点强度 = 平均信心度 × (2 - 一致性系数)
    
    一致性系数 = 不同建议数 / 总建议数
    一致性越高，强度越高
    
    示例：
    - 3轮都建议买入，平均信心0.8: 0.8 × (2 - 0.33) = 1.34 (强)
    - 3轮建议不一致，平均信心0.8: 0.8 × (2 - 1.0) = 0.8 (中)
    """
    confidences = [v.get("confidence", 0.5) for v in views]
    avg_confidence = sum(confidences) / len(confidences)
    
    recommendations = [v.get("recommendation", "HOLD") for v in views]
    consistency = len(set(recommendations)) / len(recommendations)
    
    strength = avg_confidence * (2 - consistency)
    return min(1.0, max(0.0, strength))
```

#### 辩论总结生成

```python
def _generate_debate_summary(
    bull_views: List[Dict],
    bear_views: List[Dict],
    decision: Dict
) -> str:
    """
    根据辩论轮数、最终建议和关键论点生成总结
    
    格式: "经过N轮激烈辩论，[结论]。看涨主要理由：[...]。看跌主要理由：[...]"
    """
    bull_points = len(bull_views)
    bear_points = len(bear_views)
    recommendation = decision.get("recommendation", "HOLD")
    
    summary = f"经过{max(bull_points, bear_points)}轮激烈辩论，"
    
    if recommendation == "BUY":
        summary += "看涨观点占据上风，建议买入。"
    elif recommendation == "SELL":
        summary += "看跌观点更有说服力，建议卖出。"
    else:
        summary += "多空双方势均力敌，建议持有观望。"
    
    return summary
```

---

### 1.2 风险辩论（三方博弈）

#### 辩论参与方

1. **激进风险分析师**: 倡导高回报、高风险策略
2. **保守风险分析师**: 强调风险控制、稳健增长
3. **中性风险分析师**: 平衡风险与收益

#### 风险等级判定

```python
def _get_risk_level(risk_score: float) -> str:
    """
    风险等级划分：
    - HIGH: risk_score ≥ 0.7 (高风险，谨慎操作)
    - MEDIUM: 0.4 ≤ risk_score < 0.7 (中等风险，适度参与)
    - LOW: risk_score < 0.4 (低风险，可积极布局)
    """
    if risk_score >= 0.7:
        return "HIGH"
    elif risk_score >= 0.4:
        return "MEDIUM"
    else:
        return "LOW"
```

#### 仓位建议生成

```python
def _generate_position_advice(risk_score: float, analysis_data: Dict) -> Dict:
    """
    基础仓位 = max(5, min(30, int((1 - risk_score) × 40)))
    调整仓位 = 基础仓位 × (0.5 + 信心度)
    
    示例：
    - 低风险(0.2), 高信心(0.8): 
      基础 = (1-0.2)×40 = 32% → 30% (上限)
      调整 = 30 × (0.5+0.8) = 39% → 建议30-45%
    
    - 高风险(0.8), 中信心(0.5):
      基础 = (1-0.8)×40 = 8%
      调整 = 8 × (0.5+0.5) = 8% → 建议4-12%
    
    返回：
    {
        'recommended_position': 建议仓位,
        'max_position': 最大仓位 (建议 × 1.5),
        'min_position': 最小仓位 (建议 × 0.5),
        'risk_adjusted': True,
        'notes': 仓位建议说明
    }
    """
    base_position = max(5, min(30, int((1 - risk_score) * 40)))
    confidence = analysis_data.get("confidence", 0.5)
    adjusted_position = base_position * (0.5 + confidence)
    
    return {
        "recommended_position": round(adjusted_position, 1),
        "max_position": round(adjusted_position * 1.5, 1),
        "min_position": round(adjusted_position * 0.5, 1),
        "risk_adjusted": True,
        "notes": f"基于{_get_risk_level(risk_score)}风险等级的仓位建议"
    }
```

---

## 二、风险评估与仓位管理

### 2.1 风险调整仓位算法

**文件位置**: `backend/api/debate_api.py`

```python
def _adjust_position_by_risk(base_position: float, risk_score: float) -> float:
    """
    风险调整系数 = 1.5 - risk_score
    调整后仓位 = 基础仓位 × 风险调整系数
    
    限制范围: [2%, 50%]
    
    风险等级与调整系数对照表：
    ┌─────────────┬──────────┬─────────┬──────────┐
    │ 风险等级    │ 风险分数 │ 调整系数│ 10%仓位  │
    ├─────────────┼──────────┼─────────┼──────────┤
    │ 极低风险    │ 0.1      │ 1.4     │ 14%      │
    │ 低风险      │ 0.3      │ 1.2     │ 12%      │
    │ 中等风险    │ 0.5      │ 1.0     │ 10%      │
    │ 高风险      │ 0.7      │ 0.8     │ 8%       │
    │ 极高风险    │ 0.9      │ 0.6     │ 6%       │
    └─────────────┴──────────┴─────────┴──────────┘
    """
    risk_multiplier = 1.5 - risk_score
    adjusted = base_position * risk_multiplier
    return max(2, min(50, adjusted))
```

### 2.2 止损止盈计算

```python
def calculate_stop_loss_take_profit(
    current_price: float,
    stop_loss_pct: float = 0.05,
    take_profit_pct: float = 0.15
) -> Tuple[float, float]:
    """
    止损价 = 当前价 × (1 - 止损百分比)
    止盈价 = 当前价 × (1 + 止盈百分比)
    
    默认配置：
    - 止损: 5%
    - 止盈: 15%
    - 风险收益比: 1:3
    
    策略类型对照表：
    ┌──────────┬────────┬────────┬──────────┐
    │ 策略类型 │ 止损   │ 止盈   │ 风险收益比│
    ├──────────┼────────┼────────┼──────────┤
    │ 保守型   │ 5%     │ 15%    │ 1:3      │
    │ 平衡型   │ 8%     │ 25%    │ 1:3.1    │
    │ 激进型   │ 12%    │ 40%    │ 1:3.3    │
    └──────────┴────────┴────────┴──────────┘
    """
    stop_loss = current_price * (1 - stop_loss_pct)
    take_profit = current_price * (1 + take_profit_pct)
    return stop_loss, take_profit
```

### 2.3 风险收益比计算

```python
def calculate_risk_reward_ratio(
    current_price: float,
    stop_loss: float,
    take_profit: float
) -> float:
    """
    风险收益比 = (止盈价 - 当前价) / (当前价 - 止损价)
    
    评级标准：
    - 优秀: ≥ 3.0 (潜在收益是风险的3倍以上)
    - 良好: 2.0 - 3.0
    - 可接受: 1.5 - 2.0
    - 不建议: < 1.5
    
    示例：
    - 当前价100, 止损95, 止盈115
    - 风险收益比 = (115-100)/(100-95) = 15/5 = 3.0 (优秀)
    """
    potential_profit = take_profit - current_price
    potential_loss = current_price - stop_loss
    
    if potential_loss <= 0:
        return 0
    
    ratio = potential_profit / potential_loss
    return round(ratio, 2)
```

---

## 三、策略配置系统

### 3.1 默认策略配置

**文件位置**: `backend/api/verification_api.py`

```python
def _default_strategies():
    """
    系统预设三种策略配置
    """
    return [
        {
            "strategy_id": "S001",
            "name": "保守型策略",
            "description": "低风险，稳健收益",
            "parameters": {
                "max_position": 0.3,        # 最大仓位30%
                "stop_loss": 0.05,          # 止损5%
                "take_profit": 0.15,        # 止盈15%
                "confidence_threshold": 0.7  # 信心阈值70%
            }
        },
        {
            "strategy_id": "S002",
            "name": "平衡型策略",
            "description": "风险收益平衡",
            "parameters": {
                "max_position": 0.5,        # 最大仓位50%
                "stop_loss": 0.08,          # 止损8%
                "take_profit": 0.25,        # 止盈25%
                "confidence_threshold": 0.6  # 信心阈值60%
            }
        },
        {
            "strategy_id": "S003",
            "name": "激进型策略",
            "description": "高风险，高收益",
            "parameters": {
                "max_position": 0.7,        # 最大仓位70%
                "stop_loss": 0.12,          # 止损12%
                "take_profit": 0.40,        # 止盈40%
                "confidence_threshold": 0.5  # 信心阈值50%
            }
        }
    ]
```

### 3.2 策略选择逻辑

```python
def select_strategy(
    risk_tolerance: str,
    investment_horizon: str,
    market_condition: str
) -> str:
    """
    根据投资者特征选择策略
    
    决策矩阵：
    ┌──────────┬──────────┬──────────┬──────────┐
    │ 风险承受 │ 投资期限 │ 市场状况 │ 推荐策略 │
    ├──────────┼──────────┼──────────┼──────────┤
    │ 低       │ 短期     │ 震荡     │ 保守型   │
    │ 低       │ 长期     │ 上涨     │ 平衡型   │
    │ 中       │ 中期     │ 上涨     │ 平衡型   │
    │ 中       │ 短期     │ 震荡     │ 平衡型   │
    │ 高       │ 短期     │ 上涨     │ 激进型   │
    │ 高       │ 中期     │ 上涨     │ 激进型   │
    └──────────┴──────────┴──────────┴──────────┘
    """
    if risk_tolerance == "LOW":
        return "保守型策略"
    elif risk_tolerance == "HIGH" and market_condition == "BULL":
        return "激进型策略"
    else:
        return "平衡型策略"
```

---

## 四、动态调整机制

### 4.1 市场环境感知

```python
def detect_market_condition(
    market_data: Dict,
    sentiment_score: float,
    volatility: float
) -> str:
    """
    市场状况判定
    
    判定规则：
    1. 牛市: 大盘涨幅>5% AND 情绪>0.3 AND 波动率<0.3
    2. 熊市: 大盘跌幅>5% AND 情绪<-0.3 AND 波动率>0.4
    3. 震荡: 其他情况
    
    返回: "BULL" | "BEAR" | "SIDEWAYS"
    """
    market_return = market_data.get("return", 0)
    
    if market_return > 0.05 and sentiment_score > 0.3 and volatility < 0.3:
        return "BULL"
    elif market_return < -0.05 and sentiment_score < -0.3 and volatility > 0.4:
        return "BEAR"
    else:
        return "SIDEWAYS"
```

### 4.2 仓位动态调整

```python
def dynamic_position_adjustment(
    current_position: float,
    market_condition: str,
    portfolio_performance: float
) -> float:
    """
    根据市场状况和组合表现动态调整仓位
    
    调整规则：
    1. 牛市 + 盈利: 加仓20%
    2. 牛市 + 亏损: 保持不变
    3. 熊市 + 盈利: 减仓30%
    4. 熊市 + 亏损: 减仓50%
    5. 震荡市: 保持不变
    """
    if market_condition == "BULL" and portfolio_performance > 0:
        return min(current_position * 1.2, 0.8)  # 最多80%
    elif market_condition == "BEAR" and portfolio_performance < 0:
        return current_position * 0.5  # 减半
    elif market_condition == "BEAR" and portfolio_performance > 0:
        return current_position * 0.7  # 减30%
    else:
        return current_position
```

---

## 五、风险预警系统

### 5.1 风险指标监控

```python
def calculate_risk_indicators(portfolio: Dict) -> Dict:
    """
    计算组合风险指标
    
    返回指标：
    {
        'concentration_risk': 集中度风险 (0-1),
        'volatility_risk': 波动率风险 (0-1),
        'drawdown_risk': 回撤风险 (0-1),
        'liquidity_risk': 流动性风险 (0-1),
        'overall_risk': 综合风险评分 (0-1)
    }
    """
    # 集中度风险：单一持仓占比
    max_position_pct = max(p['weight'] for p in portfolio['positions'])
    concentration_risk = min(max_position_pct / 0.3, 1.0)  # 30%为警戒线
    
    # 波动率风险
    returns = portfolio['daily_returns']
    volatility = np.std(returns) * np.sqrt(252)  # 年化波动率
    volatility_risk = min(volatility / 0.3, 1.0)  # 30%为警戒线
    
    # 回撤风险
    max_drawdown = portfolio['max_drawdown']
    drawdown_risk = min(max_drawdown / 0.2, 1.0)  # 20%为警戒线
    
    # 综合风险
    overall_risk = (
        concentration_risk * 0.3 +
        volatility_risk * 0.4 +
        drawdown_risk * 0.3
    )
    
    return {
        'concentration_risk': round(concentration_risk, 2),
        'volatility_risk': round(volatility_risk, 2),
        'drawdown_risk': round(drawdown_risk, 2),
        'overall_risk': round(overall_risk, 2)
    }
```

### 5.2 风险预警触发

```python
def check_risk_alerts(risk_indicators: Dict) -> List[str]:
    """
    检查风险预警
    
    预警等级：
    - 红色预警: 风险指标 > 0.8
    - 黄色预警: 风险指标 > 0.6
    - 绿色: 风险指标 ≤ 0.6
    """
    alerts = []
    
    if risk_indicators['concentration_risk'] > 0.8:
        alerts.append("🔴 集中度风险过高，建议分散投资")
    elif risk_indicators['concentration_risk'] > 0.6:
        alerts.append("🟡 集中度风险偏高，注意分散")
    
    if risk_indicators['volatility_risk'] > 0.8:
        alerts.append("🔴 波动率风险过高，建议降低仓位")
    elif risk_indicators['volatility_risk'] > 0.6:
        alerts.append("🟡 波动率风险偏高，谨慎操作")
    
    if risk_indicators['drawdown_risk'] > 0.8:
        alerts.append("🔴 回撤风险严重，建议止损")
    elif risk_indicators['drawdown_risk'] > 0.6:
        alerts.append("🟡 回撤风险偏高，设置止损")
    
    return alerts
```

---

## 📌 相关文档

- [核心逻辑与算法-第1部分](./项目核心逻辑与算法-第1部分-过滤与评分.md) - 过滤与评分算法
- [核心逻辑与算法-第3部分](./项目核心逻辑与算法-第3部分-交易与验证.md) - 交易决策与闭环验证
- [智能体提示词完整文档](./智能体提示词完整文档-第1部分.md) - 智能体提示词
