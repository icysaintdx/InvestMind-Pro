# SSE 断开导致后端卡死修复

**修复日期**: 2025-12-11  
**问题**: 切换标签页或切出应用后，后端停止执行  
**严重程度**: 🔴 致命（完全阻塞分析流程）

---

## 🐛 问题描述

### 现象

1. **PC 端切换标签页**：
   - 分析进行到一半
   - 切换到其他标签页
   - 切回来：前端显示"等待分析..."，后端没有任何日志
   - 分析完全卡死

2. **手机切出应用**：
   - 分析进行中
   - 切出到其他应用
   - 切回来：显示"已从后端恢复分析状态"
   - 但所有智能体都是"等待分析..."
   - 后端日志停在某个智能体完成后，不再继续

### 根本原因

**SSE 连接断开后，队列被删除，导致后端执行阻塞！**

```python
# ❌ 旧代码（有问题）
finally:
    # 清理队列
    async with queue_lock:
        if agent_id in agent_log_queues:
            del agent_log_queues[agent_id]  # ❌ 删除队列
```

**问题链**：
```
用户切换标签页/切出应用
  ↓
浏览器暂停 SSE 连接
  ↓
SSE finally 块执行
  ↓
删除日志队列 ❌
  ↓
后端智能体尝试推送日志
  ↓
队列不存在 → 创建新队列
  ↓
但没有 SSE 连接消费日志
  ↓
队列堆积 → 可能阻塞
  ↓
后端执行卡死 ❌
```

---

## ✅ 解决方案

### 方案1: 不删除队列，只清空

```python
# ✅ 新代码（修复）
finally:
    # 不删除队列，只清空它，让后端可以继续执行
    async with queue_lock:
        if agent_id in agent_log_queues:
            # 清空队列但不删除
            while not agent_log_queues[agent_id].empty():
                try:
                    agent_log_queues[agent_id].get_nowait()
                except:
                    break
            logger.info(f"[SSE] 清空队列（保留）: {agent_id}")
```

**优点**：
- ✅ 后端可以继续推送日志
- ✅ 队列不会无限增长（定期清空）
- ✅ 重新连接时可以立即使用

### 方案2: 队列满时丢弃旧日志

```python
# ✅ 限制队列大小，防止内存溢出
agent_log_queues[agent_id] = asyncio.Queue(maxsize=100)

# ✅ 队列满时丢弃最旧的日志
try:
    agent_log_queues[agent_id].put_nowait(log_entry)
except asyncio.QueueFull:
    # 丢弃最旧的日志
    try:
        agent_log_queues[agent_id].get_nowait()
        agent_log_queues[agent_id].put_nowait(log_entry)
    except:
        pass  # 静默失败，不阻塞后端执行
```

**优点**：
- ✅ 防止队列无限增长
- ✅ 不阻塞后端执行
- ✅ 保留最新的日志

### 方案3: 日志推送失败不抛出异常

```python
# ✅ 任何错误都不应该阻塞后端执行
except Exception as e:
    logger.warning(f"[SSE] 推送日志失败（忽略）: {agent_id}, {str(e)}")
    # 不抛出异常，不阻塞后端
```

---

## 📊 修复效果对比

### 修复前

| 场景 | 前端 | 后端 | 结果 |
|------|------|------|------|
| PC 切换标签页 | 暂停 | 卡死 ❌ | 无法恢复 |
| 手机切出 | 暂停 | 卡死 ❌ | 无法恢复 |
| 切回来 | 显示"等待" | 无日志 | 完全卡死 ❌ |

### 修复后

| 场景 | 前端 | 后端 | 结果 |
|------|------|------|------|
| PC 切换标签页 | 暂停 | 继续执行 ✅ | 可恢复 |
| 手机切出 | 暂停 | 继续执行 ✅ | 可恢复 |
| 切回来 | 轮询恢复 | 正常运行 | 完全正常 ✅ |

---

## 🔧 技术细节

### SSE 生命周期

```
客户端连接
  ↓
创建队列
  ↓
发送日志
  ↓
客户端断开
  ↓
清空队列（保留） ✅
  ↓
客户端重新连接
  ↓
继续使用同一队列 ✅
```

### 队列管理策略

1. **创建时机**：
   - 首次连接时创建
   - 推送日志时如果不存在则创建

2. **清理时机**：
   - SSE 断开时清空（但不删除）
   - 分析完成时可以删除

3. **大小限制**：
   - 最大 100 条日志
   - 满了就丢弃最旧的

### 错误处理

```python
# 所有可能的错误点都要处理
try:
    queue.put_nowait(log)
except asyncio.QueueFull:
    # 队列满 → 丢弃旧日志
except Exception:
    # 其他错误 → 静默失败
```

---

## 🧪 测试验证

### 测试1: PC 端切换标签页

**步骤**：
1. 开始分析
2. 等待第一阶段完成
3. 切换到其他标签页
4. 等待 30 秒
5. 切回来

**预期结果**：
- ✅ 后端继续执行（查看终端日志）
- ✅ 前端轮询恢复状态
- ✅ 显示最新的智能体状态
- ✅ 分析继续进行

### 测试2: 手机切出应用

**步骤**：
1. 手机开始分析
2. 等待第一阶段完成
3. 切出到其他应用
4. 等待 1 分钟
5. 切回来

**预期结果**：
- ✅ 后端继续执行
- ✅ 显示"已从后端恢复分析状态"
- ✅ 耗时正确显示
- ✅ 智能体状态正确更新
- ✅ 分析继续进行

### 测试3: 长时间切出

**步骤**：
1. 开始分析
2. 立即切出
3. 等待 5 分钟（让分析在后台完成）
4. 切回来

**预期结果**：
- ✅ 后端已完成分析
- ✅ 前端轮询获取完整结果
- ✅ 显示所有智能体的输出
- ✅ 显示最终报告

---

## ⚠️ 注意事项

### 1. 队列大小

```python
maxsize=100  # 每个智能体最多 100 条日志
```

如果分析时间很长，可能会丢失一些早期日志。但这不影响分析结果，只是前端看不到完整的日志流。

### 2. 内存占用

每个智能体一个队列，最多 100 条日志，每条约 500 字节：
```
21 个智能体 × 100 条 × 500 字节 = 约 1MB
```

内存占用可忽略不计。

### 3. 重新连接

客户端重新连接时，会使用同一个队列，但之前的日志已经被清空了。这是正常的，因为：
- 前端已经通过轮询恢复了状态
- 旧日志已经没有意义了

---

## 🎯 总结

### 修复内容

1. ✅ SSE 断开时不删除队列
2. ✅ 限制队列大小防止内存溢出
3. ✅ 队列满时丢弃旧日志
4. ✅ 日志推送失败不阻塞后端

### 修复效果

- ✅ PC 端切换标签页正常
- ✅ 手机切出应用正常
- ✅ 后端不会卡死
- ✅ 前端可以恢复状态

### 后续优化

1. 可以添加队列清理定时器
2. 可以添加队列状态监控
3. 可以优化重连逻辑

---

**修复完成！** 🎉
