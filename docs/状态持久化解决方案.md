# 分析状态持久化解决方案

## 问题描述

当前系统存在以下问题：
1. **页面刷新丢失状态** - 用户刷新页面后，正在进行的分析状态丢失
2. **后台运行不同步** - 移动端切换到后台，后端完成分析但前端不更新
3. **打字机效果延迟** - 切换回前端时才开始渲染，用户体验差

## 解决方案

### 1. 状态持久化（localStorage）

**保存内容**：
- 股票代码和数据
- 分析进度（当前阶段）
- 所有智能体的状态和输出
- 分析开始时间
- 辩论结果

**保存时机**：
- 开始分析时保存初始状态
- 每秒自动保存（通过计时器）
- 每个智能体完成时保存
- 分析完成时保存最终状态

### 2. 页面恢复机制

**恢复流程**：
```
页面加载
  ↓
检查 localStorage
  ↓
有保存状态？
  ├─ 是 → 恢复状态 → 继续轮询后端
  └─ 否 → 正常显示
```

### 3. 后台同步机制

**方案A：轮询（推荐）**
- 每5秒轮询后端检查状态
- 适用于移动端后台运行
- 实现简单，兼容性好

**方案B：WebSocket**
- 实时双向通信
- 需要后端支持
- 更复杂但更实时

### 4. 会话管理（后端）

**需要后端支持**：
```python
# 后端保存分析会话
analysis_sessions = {}

@app.post("/api/analysis/start")
async def start_analysis(request):
    session_id = create_session_id()
    analysis_sessions[session_id] = {
        "stock_code": request.stock_code,
        "status": "running",
        "progress": {},
        "results": {},
        "start_time": time.time()
    }
    return {"session_id": session_id}

@app.get("/api/analysis/status/{session_id}")
async def get_status(session_id):
    return analysis_sessions.get(session_id)
```

## 实现步骤

### 第一阶段：前端状态持久化 ✅
1. 创建 `analysisState.js` 工具
2. 在 `startAnalysis` 中保存状态
3. 在页面加载时恢复状态
4. 每秒自动保存进度

### 第二阶段：轮询机制
1. 添加轮询函数 `pollAnalysisStatus()`
2. 页面可见性 API 监听
3. 后台时继续轮询
4. 前台时更新 UI

### 第三阶段：后端会话支持
1. 后端添加会话管理
2. 返回 session_id
3. 提供状态查询 API
4. 清理过期会话

## 代码示例

### 前端：保存状态
```javascript
function saveCurrentState() {
  const state = {
    stockCode: stockCode.value,
    stockData: stockData.value,
    isAnalyzing: isAnalyzing.value,
    agentStatus: agentStatus.value,
    agentOutputs: agentOutputs.value,
    analysisStartTime: analysisStartTime.value,
    showReport: showReport.value
  }
  saveAnalysisState(state)
}
```

### 前端：恢复状态
```javascript
onMounted(() => {
  const savedState = loadAnalysisState()
  if (savedState) {
    console.log('[状态恢复] 发现保存的分析状态')
    restoreState(savedState)
    startPolling() // 开始轮询
  }
})
```

### 前端：轮询
```javascript
function startPolling() {
  pollingInterval = setInterval(async () => {
    // 检查后端状态
    const status = await checkBackendStatus()
    if (status.completed) {
      // 更新UI
      updateFromBackend(status)
      stopPolling()
    }
  }, 5000) // 每5秒
}
```

## 优化建议

### 性能优化
1. **节流保存** - 不要每次状态变化都保存，使用节流
2. **压缩数据** - localStorage 有大小限制（5-10MB）
3. **清理过期** - 定期清理超时的状态

### 用户体验
1. **恢复提示** - 显示"继续上次分析"的提示
2. **进度显示** - 清晰显示当前进度
3. **错误处理** - 后端异常时的降级方案

### 移动端优化
1. **Page Visibility API** - 监听页面可见性
2. **Service Worker** - 后台同步（高级）
3. **通知** - 分析完成时推送通知

## 注意事项

1. **隐私** - localStorage 数据不加密，注意敏感信息
2. **容量** - localStorage 有大小限制，定期清理
3. **兼容性** - 旧浏览器可能不支持
4. **同步** - 多标签页可能冲突，需要处理

## 测试场景

1. ✅ 分析进行中刷新页面
2. ✅ 移动端切换到后台
3. ✅ 网络断开重连
4. ✅ 浏览器崩溃恢复
5. ✅ 多标签页同时分析

## 时间估算

- 第一阶段（状态持久化）：2小时
- 第二阶段（轮询机制）：3小时
- 第三阶段（后端支持）：4小时
- 测试和优化：3小时
- **总计**：12小时

## 当前进度

- [x] 创建状态管理工具
- [x] 添加状态保存逻辑
- [ ] 添加状态恢复逻辑
- [ ] 实现轮询机制
- [ ] 后端会话支持
- [ ] 测试和优化
