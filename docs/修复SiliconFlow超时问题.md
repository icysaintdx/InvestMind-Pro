# 修复SiliconFlow API超时问题报告

## 问题描述
- **现象**：整个分析流程从第二阶段开始全部超时，耗时49分钟
- **影响**：第二、三、四阶段的所有智能体全部失败
- **重试情况**：每个智能体重试3次，每次180秒，总共540秒（9分钟）
- **时间统计**：
  - 第一阶段：部分成功（technical 110秒，fundamental 146秒）
  - 第二阶段：5个智能体全部超时（每个540秒）
  - 第三阶段：6个智能体全部超时（每个540秒）
  - 第四阶段：3个智能体全部超时（每个540秒）

## 根本原因分析

### 1. 超时配置不匹配
- **前端超时**：180秒
- **后端读取超时**：120秒
- **问题**：后端在120秒就超时，但前端还在等待，导致重试机制失效

### 2. 连接池限制过严
- **原配置**：
  - max_connections: 10
  - max_keepalive_connections: 5
- **问题**：多个智能体并发请求时，连接池容易耗尽

### 3. 缺乏并发控制
- **第二阶段**：5个智能体同时请求
- **第三阶段**：6个智能体同时请求
- **问题**：可能触发SiliconFlow API的速率限制

## 解决方案实施

### 1. 调整超时配置
```python
client = httpx.AsyncClient(
    timeout=httpx.Timeout(
        connect=30.0,      # 增加到30秒（原10秒）
        read=170.0,        # 增加到170秒（原120秒，接近前端180秒）
        write=30.0,        # 增加到30秒（原10秒）
        pool=30.0          # 增加到30秒（原10秒）
    )
)
```

### 2. 放宽连接限制
```python
limits=httpx.Limits(
    max_connections=50,            # 增加到50（原10）
    max_keepalive_connections=20   # 增加到20（原5）
)
```

### 3. 添加全局并发控制
```python
# 全局并发控制器
siliconflow_semaphore = asyncio.Semaphore(3)  # 最多3个并发请求

@app.post("/api/ai/siliconflow")
async def siliconflow_api(request: SiliconFlowRequest):
    async with siliconflow_semaphore:  # 限制并发
        # ... 处理请求 ...
```

## 修改位置
- **文件**：`d:\InvestMindPro\backend\server.py`
- **函数**：`siliconflow_api`
- **行数**：约416-554行

## 预期效果
1. **减少超时**：后端超时时间接近前端，减少无效等待
2. **提高并发能力**：增加连接池容量，支持更多并发请求
3. **避免速率限制**：通过Semaphore控制并发数，避免触发API限制
4. **总时间优化**：预计从49分钟减少到10-15分钟

## 后续优化建议
1. **前端批次控制**：考虑减少第二、三阶段的并发数
2. **智能重试**：根据错误类型决定是否重试
3. **缓存机制**：对相同请求进行缓存，减少API调用
4. **监控告警**：添加超时和失败的监控指标

## 测试建议
1. 先测试单个智能体，确认超时配置生效
2. 测试并发3个智能体，验证Semaphore控制
3. 完整运行四个阶段，验证整体优化效果

---
*修复时间：2024-12-06 20:30*  
*修复人：AI Assistant*
