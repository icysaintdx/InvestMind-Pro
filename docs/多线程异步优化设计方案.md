# InvestMindPro 多线程异步优化设计方案

> **实施状态**: 第一阶段已完成 ✅
> **更新日期**: 2025-12-21

## 实施进度

| 阶段 | 状态 | 说明 |
|------|------|------|
| 第一阶段：基础设施 | ✅ 完成 | Redis客户端、TaskManager、SSE端点、前端客户端 |
| 第二阶段：核心改造 | 🔄 进行中 | 异步分析API已完成，演示页面已创建 |
| 第三阶段：优化完善 | ⏳ 待开始 | 数据源异步化、性能优化 |

## 已完成的文件

### 后端
- `backend/services/async_task/__init__.py` - 模块入口
- `backend/services/async_task/redis_client.py` - Redis客户端（支持内存降级）
- `backend/services/async_task/task_manager.py` - 异步任务管理器
- `backend/services/async_task/log_streamer.py` - 实时日志流服务
- `backend/api/sse_api.py` - SSE实时推送端点
- `backend/api/async_analysis_api.py` - 异步分析API
- `backend/tests/test_async_task.py` - 测试脚本

### 前端
- `alpha-council-vue/src/utils/sseClient.js` - SSE客户端封装
- `alpha-council-vue/src/utils/asyncAnalysisService.js` - 异步分析服务
- `alpha-council-vue/src/views/AsyncAnalysisDemo.vue` - 异步分析演示页面

### 修改的文件
- `backend/requirements.txt` - 添加redis, sse-starlette等依赖
- `backend/server.py` - 集成SSE路由和Redis初始化
- `alpha-council-vue/src/App.vue` - 添加异步演示页面入口

---

## 1. 当前架构问题分析

### 1.1 后端问题

| 问题 | 影响 | 严重程度 |
|------|------|----------|
| SQLAlchemy 同步操作 | 阻塞事件循环 | 高 |
| AI API 长时间等待 (120-180秒) | 前端超时 | 高 |
| 数据源同步调用 (AKShare/Tushare) | 串行执行慢 | 中 |
| 内存会话存储 | 不支持分布式 | 中 |
| Agent 串行执行 | 分析时间长 | 高 |

### 1.2 前端问题

| 问题 | 影响 | 严重程度 |
|------|------|----------|
| 阶段串行执行 | 必须等待上一阶段完成 | 高 |
| 轮询机制 (5秒间隔) | 实时性差、资源浪费 | 中 |
| 超时配置过长 (最长6分钟) | 用户体验差 | 中 |
| 无增量更新 | 看不到实时进度 | 高 |

## 2. 优化方案设计

### 2.1 后端异步任务队列系统

```
┌─────────────────────────────────────────────────────────────┐
│                      FastAPI Server                          │
├─────────────────────────────────────────────────────────────┤
│  HTTP Request → 立即返回 task_id → 任务入队                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Redis Task Queue                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │
│  │ 高优先级 │  │ 普通队列 │  │ 低优先级 │  │ 日志队列 │        │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Worker Pool (多进程)                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │ Worker 1 │  │ Worker 2 │  │ Worker 3 │  │ Worker N │    │
│  │ (Agent)  │  │ (Agent)  │  │ (Data)   │  │ (AI API) │    │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │
└─────────────────────────────────────────────────────────────┘
```

#### 核心组件

**1. TaskManager (任务管理器)**
```python
# backend/services/task_manager.py
class TaskManager:
    """异步任务管理器"""

    async def submit_task(self, task_type: str, payload: dict) -> str:
        """提交任务，立即返回task_id"""
        task_id = str(uuid.uuid4())
        await self.redis.lpush(f"queue:{task_type}", json.dumps({
            "task_id": task_id,
            "payload": payload,
            "created_at": datetime.now().isoformat()
        }))
        return task_id

    async def get_task_status(self, task_id: str) -> dict:
        """获取任务状态"""
        return await self.redis.hgetall(f"task:{task_id}")

    async def update_progress(self, task_id: str, progress: int, message: str):
        """更新任务进度"""
        await self.redis.hset(f"task:{task_id}", mapping={
            "progress": progress,
            "message": message,
            "updated_at": datetime.now().isoformat()
        })
        # 发布进度更新事件
        await self.redis.publish(f"progress:{task_id}", json.dumps({
            "progress": progress,
            "message": message
        }))
```

**2. AsyncWorker (异步工作器)**
```python
# backend/workers/async_worker.py
class AsyncWorker:
    """异步任务工作器"""

    async def run(self):
        while True:
            # 从队列获取任务
            task_data = await self.redis.brpop("queue:analysis", timeout=30)
            if task_data:
                await self.process_task(json.loads(task_data[1]))

    async def process_task(self, task: dict):
        task_id = task["task_id"]
        try:
            await self.task_manager.update_progress(task_id, 0, "开始处理")
            result = await self.execute(task["payload"])
            await self.task_manager.complete_task(task_id, result)
        except Exception as e:
            await self.task_manager.fail_task(task_id, str(e))
```

### 2.2 SSE 实时推送机制

```
┌──────────┐         ┌──────────┐         ┌──────────┐
│  前端    │ ──SSE──▶│  FastAPI │◀──Sub──▶│  Redis   │
│ Browser  │◀────────│  Server  │         │  PubSub  │
└──────────┘         └──────────┘         └──────────┘
```

**SSE 端点实现**
```python
# backend/api/sse_api.py
from fastapi import APIRouter
from sse_starlette.sse import EventSourceResponse

router = APIRouter()

@router.get("/api/sse/task/{task_id}")
async def task_progress_stream(task_id: str):
    """SSE 任务进度流"""
    async def event_generator():
        pubsub = redis.pubsub()
        await pubsub.subscribe(f"progress:{task_id}")

        try:
            async for message in pubsub.listen():
                if message["type"] == "message":
                    yield {
                        "event": "progress",
                        "data": message["data"]
                    }
        finally:
            await pubsub.unsubscribe(f"progress:{task_id}")

    return EventSourceResponse(event_generator())

@router.get("/api/sse/analysis/{session_id}")
async def analysis_stream(session_id: str):
    """分析会话实时流"""
    async def event_generator():
        pubsub = redis.pubsub()
        await pubsub.subscribe(f"analysis:{session_id}")

        async for message in pubsub.listen():
            if message["type"] == "message":
                data = json.loads(message["data"])
                yield {
                    "event": data.get("event", "update"),
                    "data": json.dumps(data)
                }

    return EventSourceResponse(event_generator())
```

### 2.3 前端非阻塞交互方案

**1. SSE 客户端封装**
```javascript
// src/services/sseClient.js
class SSEClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl
    this.connections = new Map()
  }

  connect(taskId, handlers) {
    const eventSource = new EventSource(
      `${this.baseUrl}/api/sse/task/${taskId}`
    )

    eventSource.addEventListener('progress', (e) => {
      const data = JSON.parse(e.data)
      handlers.onProgress?.(data)
    })

    eventSource.addEventListener('complete', (e) => {
      const data = JSON.parse(e.data)
      handlers.onComplete?.(data)
      this.disconnect(taskId)
    })

    eventSource.addEventListener('error', (e) => {
      handlers.onError?.(e)
    })

    this.connections.set(taskId, eventSource)
    return eventSource
  }

  disconnect(taskId) {
    const conn = this.connections.get(taskId)
    if (conn) {
      conn.close()
      this.connections.delete(taskId)
    }
  }
}
```

**2. 分析流程改造**
```javascript
// src/views/AnalysisView.vue 改造
async startAnalysis() {
  // 1. 提交分析任务，立即返回
  const { task_id, session_id } = await this.submitAnalysisTask()

  // 2. 建立 SSE 连接，接收实时更新
  this.sseClient.connect(session_id, {
    onProgress: (data) => {
      // 实时更新 Agent 状态
      this.updateAgentStatus(data.agent_id, data.status, data.progress)
      // 实时显示日志
      this.appendLog(data.log)
    },
    onAgentComplete: (data) => {
      // Agent 完成，立即显示结果
      this.setAgentResult(data.agent_id, data.result)
    },
    onStageComplete: (data) => {
      // 阶段完成
      this.completeStage(data.stage)
    },
    onComplete: (data) => {
      // 全部完成
      this.analysisComplete(data)
    }
  })

  // 3. 前端立即可交互，不阻塞
  this.isAnalyzing = true
}
```

### 2.4 Agent 并行执行架构

```
                    ┌─────────────────┐
                    │   分析请求入口   │
                    └────────┬────────┘
                             │
                             ▼
┌────────────────────────────────────────────────────────────┐
│                      Stage 1: 分析师层                      │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐   │
│  │宏观分析│ │行业分析│ │技术分析│ │资金分析│ │基本面  │   │
│  │  师    │ │  师    │ │  师    │ │  师    │ │ 分析师 │   │
│  └───┬────┘ └───┬────┘ └───┬────┘ └───┬────┘ └───┬────┘   │
│      │          │          │          │          │        │
│      └──────────┴──────────┼──────────┴──────────┘        │
│                            │ (并行执行)                    │
└────────────────────────────┼───────────────────────────────┘
                             ▼
┌────────────────────────────────────────────────────────────┐
│                      Stage 2: 研究总监层                    │
│         ┌──────────────┐       ┌──────────────┐            │
│         │基本面研究总监│       │市场动量总监  │            │
│         └──────┬───────┘       └──────┬───────┘            │
│                └───────────┬──────────┘                    │
│                            │ (并行执行)                    │
└────────────────────────────┼───────────────────────────────┘
                             ▼
┌────────────────────────────────────────────────────────────┐
│                      Stage 3: 风控层                        │
│         ┌──────────────┐       ┌──────────────┐            │
│         │系统风险总监  │       │组合风险总监  │            │
│         └──────┬───────┘       └──────┬───────┘            │
│                └───────────┬──────────┘                    │
│                            │ (并行执行)                    │
└────────────────────────────┼───────────────────────────────┘
                             ▼
┌────────────────────────────────────────────────────────────┐
│                      Stage 4: 决策层                        │
│                   ┌──────────────┐                         │
│                   │投资决策总经理│                         │
│                   └──────────────┘                         │
└────────────────────────────────────────────────────────────┘
```

**并行执行实现**
```python
# backend/services/parallel_executor.py
class ParallelAgentExecutor:
    """Agent 并行执行器"""

    async def execute_stage(self, stage: int, agents: List[str], context: dict):
        """并行执行同一阶段的所有 Agent"""
        tasks = []
        for agent_id in agents:
            task = asyncio.create_task(
                self.execute_agent(agent_id, context)
            )
            tasks.append(task)

        # 并行等待所有 Agent 完成
        results = await asyncio.gather(*tasks, return_exceptions=True)

        return {
            agent_id: result
            for agent_id, result in zip(agents, results)
        }

    async def execute_agent(self, agent_id: str, context: dict):
        """执行单个 Agent"""
        agent = self.get_agent(agent_id)

        # 发布开始事件
        await self.publish_event(context["session_id"], {
            "event": "agent_start",
            "agent_id": agent_id
        })

        try:
            result = await agent.analyze(context)

            # 发布完成事件
            await self.publish_event(context["session_id"], {
                "event": "agent_complete",
                "agent_id": agent_id,
                "result": result
            })

            return result
        except Exception as e:
            await self.publish_event(context["session_id"], {
                "event": "agent_error",
                "agent_id": agent_id,
                "error": str(e)
            })
            raise
```

### 2.5 实时日志推送机制

```python
# backend/services/log_streamer.py
class LogStreamer:
    """实时日志流"""

    def __init__(self, redis_client):
        self.redis = redis_client

    async def log(self, session_id: str, level: str, message: str,
                  agent_id: str = None, extra: dict = None):
        """记录并推送日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "level": level,
            "message": message,
            "agent_id": agent_id,
            **(extra or {})
        }

        # 存储日志
        await self.redis.lpush(f"logs:{session_id}", json.dumps(log_entry))

        # 实时推送
        await self.redis.publish(f"analysis:{session_id}", json.dumps({
            "event": "log",
            "data": log_entry
        }))

    async def get_logs(self, session_id: str, start: int = 0,
                       count: int = 100) -> List[dict]:
        """获取历史日志"""
        logs = await self.redis.lrange(f"logs:{session_id}", start, start + count)
        return [json.loads(log) for log in logs]
```

## 3. 数据库异步化

### 3.1 SQLAlchemy 异步改造

```python
# backend/database/async_db.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

# 异步引擎
async_engine = create_async_engine(
    "sqlite+aiosqlite:///InvestMindPro.db",
    echo=False
)

# 异步会话工厂
AsyncSessionLocal = sessionmaker(
    async_engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# 异步依赖注入
async def get_async_db():
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

### 3.2 异步数据源调用

```python
# backend/dataflows/async_data_source.py
import aiohttp
import asyncio

class AsyncDataSource:
    """异步数据源"""

    async def fetch_stock_data(self, code: str) -> dict:
        """异步获取股票数据"""
        async with aiohttp.ClientSession() as session:
            tasks = [
                self.fetch_basic_info(session, code),
                self.fetch_realtime_quote(session, code),
                self.fetch_financial_data(session, code),
            ]
            results = await asyncio.gather(*tasks, return_exceptions=True)

        return self.merge_results(results)

    async def fetch_with_fallback(self, code: str, sources: List[str]) -> dict:
        """带降级的异步获取"""
        for source in sources:
            try:
                return await self.fetch_from_source(source, code)
            except Exception as e:
                logger.warning(f"Source {source} failed: {e}")
                continue

        return self.get_cached_data(code)
```

## 4. 实施计划

### 第一阶段：基础设施 (1-2周)

| 任务 | 优先级 | 预计时间 |
|------|--------|----------|
| 安装配置 Redis | P0 | 1天 |
| 实现 TaskManager | P0 | 2天 |
| 实现 SSE 端点 | P0 | 2天 |
| 前端 SSE 客户端 | P0 | 2天 |
| 基础测试 | P0 | 2天 |

### 第二阶段：核心改造 (2-3周)

| 任务 | 优先级 | 预计时间 |
|------|--------|----------|
| SQLAlchemy 异步化 | P0 | 3天 |
| Agent 并行执行器 | P0 | 3天 |
| 分析流程改造 | P0 | 4天 |
| 日志流系统 | P1 | 2天 |
| 前端交互改造 | P0 | 3天 |

### 第三阶段：优化完善 (1-2周)

| 任务 | 优先级 | 预计时间 |
|------|--------|----------|
| 数据源异步化 | P1 | 3天 |
| 错误处理完善 | P1 | 2天 |
| 性能测试优化 | P1 | 2天 |
| 文档更新 | P2 | 1天 |

## 5. 预期效果

### 5.1 性能提升

| 指标 | 当前 | 优化后 | 提升 |
|------|------|--------|------|
| 前端响应时间 | 3-6分钟阻塞 | <1秒返回 | 99%+ |
| 单次分析时间 | 5-10分钟 | 2-4分钟 | 50%+ |
| 用户可见进度 | 无 | 实时 | - |
| 并发分析能力 | 1 | 10+ | 10x |

### 5.2 用户体验提升

- **即时反馈**: 提交分析后立即返回，不再等待
- **实时进度**: 每个 Agent 的执行状态实时可见
- **增量结果**: Agent 完成后立即显示结果，无需等待全部完成
- **日志可见**: 实时查看分析日志，便于调试和理解

## 6. 技术依赖

```
# 新增依赖
redis>=4.5.0
aioredis>=2.0.0
sse-starlette>=1.6.0
aiosqlite>=0.19.0
sqlalchemy[asyncio]>=2.0.0
aiohttp>=3.8.0
```

## 7. 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| Redis 不可用 | 任务队列失效 | 降级到内存队列 |
| SSE 连接断开 | 进度丢失 | 自动重连 + 状态恢复 |
| Worker 崩溃 | 任务丢失 | 任务持久化 + 重试机制 |
| 并发过高 | 资源耗尽 | 限流 + 队列积压告警 |
