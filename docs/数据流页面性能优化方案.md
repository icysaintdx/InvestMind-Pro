# 数据流页面性能优化方案

## 1. 问题分析

### 1.1 前端问题

| 问题 | 代码位置 | 影响 |
|------|----------|------|
| **页面加载时并发请求过多** | `onMounted()` 同时调用 4 个接口 | 后端压力大，页面卡顿 |
| **串行请求单个股票数据** | `fetchAndCacheStockData()` 串行调用 4 个接口 | 等待时间长 |
| **定时刷新无节流** | `setInterval(refreshAllData, 120000)` | 可能与手动刷新冲突 |
| **无请求取消机制** | 切换股票时旧请求仍在执行 | 数据错乱、资源浪费 |
| **无加载状态细分** | 只有一个 `loadingComprehensive` | 用户不知道哪个在加载 |

**前端请求流程问题：**
```
页面加载时:
├── loadDataSources()        ← 检测数据源（可能很慢）
├── refreshAllData()         ← 同时触发
│   ├── loadMonitoredStocks()
│   ├── loadNews()
│   └── loadDailyStats()
├── loadNotificationChannels()
└── loadConfigGuide()

查看股票详情时:
└── fetchAndCacheStockData(code)
    ├── axios.get(/comprehensive/{code})  ← 串行等待
    ├── axios.get(/news/{code})           ← 串行等待
    ├── axios.get(/sentiment/{code})      ← 串行等待
    └── axios.get(/risk/{code})           ← 串行等待
```

### 1.2 后端问题

| 问题 | 代码位置 | 影响 |
|------|----------|------|
| **数据源检测阻塞** | `_check_all_data_sources()` 同步调用 | 首次请求慢 |
| **综合数据接口内部串行** | `get_all_stock_data()` | 响应时间长 |
| **新闻+情绪分析重复获取** | `/news` 和 `/sentiment` 都获取新闻 | 重复请求 |
| **无批量接口** | 每个股票单独请求 | N 只股票 = N*4 次请求 |
| **缓存策略不统一** | 各接口独立缓存 | 数据不一致 |

**后端接口调用链：**
```
/stock/comprehensive/{code}
└── get_comprehensive_service().get_all_stock_data()
    ├── 实时行情
    ├── 停复牌状态
    ├── ST状态
    ├── 财务数据
    ├── 审计意见
    ├── 业绩预告
    ├── 分红送股
    ├── 限售解禁
    ├── 股权质押
    ├── 股东增减持
    └── 龙虎榜
    （全部串行执行！）

/stock/news/{code}
└── aggregator.aggregate_news()
    ├── Tushare新闻
    ├── AKShare新闻
    └── 市场要闻
└── engine.analyze_news_list()  ← 情绪分析

/stock/sentiment/{code}
└── aggregator.aggregate_news()  ← 重复获取新闻！
└── engine.analyze_news_list()
```

### 1.3 核心瓶颈

1. **前端串行请求**: 4 个接口串行调用，总时间 = T1 + T2 + T3 + T4
2. **后端串行处理**: 综合数据接口内部 10+ 个数据源串行获取
3. **重复数据获取**: 新闻和情绪分析接口重复获取新闻
4. **无批量能力**: 多只股票需要多次请求

---

## 2. 优化方案

### 2.1 前端优化

#### 2.1.1 并行请求改造

**当前代码：**
```javascript
// fetchAndCacheStockData - 串行
const comprehensiveResp = await axios.get(`/comprehensive/${code}`)
const newsResp = await axios.get(`/news/${code}`)
const sentimentResp = await axios.get(`/sentiment/${code}`)
const riskResp = await axios.get(`/risk/${code}`)
```

**优化后：**
```javascript
// 并行请求
const [comprehensiveResp, newsResp, riskResp] = await Promise.all([
  axios.get(`/comprehensive/${code}`),
  axios.get(`/news/${code}`),  // 新闻已包含情绪分析
  axios.get(`/risk/${code}`)
])
// 注意：移除单独的 sentiment 请求，合并到 news 接口
```

#### 2.1.2 请求取消机制

```javascript
// 使用 AbortController
const abortController = ref(null)

const fetchAndCacheStockData = async (code) => {
  // 取消之前的请求
  if (abortController.value) {
    abortController.value.abort()
  }
  abortController.value = new AbortController()

  try {
    const [comprehensive, news, risk] = await Promise.all([
      axios.get(`/comprehensive/${code}`, { signal: abortController.value.signal }),
      axios.get(`/news/${code}`, { signal: abortController.value.signal }),
      axios.get(`/risk/${code}`, { signal: abortController.value.signal })
    ])
    // ...
  } catch (error) {
    if (error.name === 'CanceledError') {
      console.log('请求已取消')
      return
    }
    throw error
  }
}
```

#### 2.1.3 分阶段加载

```javascript
// 加载状态细分
const loadingStates = ref({
  comprehensive: false,
  news: false,
  risk: false
})

// 优先加载关键数据
const fetchStockDataPrioritized = async (code) => {
  // 第一优先级：综合数据（包含实时行情）
  loadingStates.value.comprehensive = true
  const comprehensive = await axios.get(`/comprehensive/${code}`)
  loadingStates.value.comprehensive = false
  comprehensiveData.value = comprehensive.data

  // 第二优先级：新闻和风险（并行）
  loadingStates.value.news = true
  loadingStates.value.risk = true

  const [news, risk] = await Promise.all([
    axios.get(`/news/${code}`),
    axios.get(`/risk/${code}`)
  ])

  loadingStates.value.news = false
  loadingStates.value.risk = false
  stockNews.value = news.data.news
  stockRisk.value = risk.data
}
```

#### 2.1.4 防抖和节流

```javascript
import { debounce, throttle } from 'lodash-es'

// 刷新按钮防抖
const refreshAllData = debounce(async () => {
  // ...
}, 1000)

// 自动刷新节流
const autoRefresh = throttle(async () => {
  if (!isRefreshing.value) {
    await refreshAllData()
  }
}, 120000)
```

### 2.2 后端优化

#### 2.2.1 综合数据接口并行化

**当前代码（串行）：**
```python
def get_all_stock_data(self, ts_code):
    result = {}
    result['realtime'] = self.get_realtime(ts_code)
    result['suspend'] = self.get_suspend(ts_code)
    result['st_status'] = self.get_st_status(ts_code)
    # ... 更多串行调用
```

**优化后（并行）：**
```python
async def get_all_stock_data_async(self, ts_code):
    """并行获取所有数据"""
    tasks = {
        'realtime': self.get_realtime_async(ts_code),
        'suspend': self.get_suspend_async(ts_code),
        'st_status': self.get_st_status_async(ts_code),
        'financial': self.get_financial_async(ts_code),
        'news': self.get_news_async(ts_code),
        # ...
    }

    results = await asyncio.gather(*tasks.values(), return_exceptions=True)

    return {
        key: result if not isinstance(result, Exception) else {'error': str(result)}
        for key, result in zip(tasks.keys(), results)
    }
```

#### 2.2.2 合并新闻和情绪接口

**新接口设计：**
```python
@router.get("/stock/news-with-sentiment/{ts_code}")
async def get_stock_news_with_sentiment(ts_code: str, limit: int = 20):
    """
    获取新闻并附带情绪分析（合并两个接口）
    """
    # 获取新闻
    news_list = await get_news(ts_code, limit)

    # 情绪分析
    sentiment_result = analyze_sentiment(news_list)

    return {
        "success": True,
        "news": news_list,
        "sentiment_summary": sentiment_result['summary'],
        "overall_score": sentiment_result['overall_score']
    }
```

#### 2.2.3 批量接口

```python
@router.post("/stock/batch")
async def get_batch_stock_data(codes: List[str], fields: List[str] = None):
    """
    批量获取多只股票数据

    Args:
        codes: 股票代码列表
        fields: 需要的字段 ['comprehensive', 'news', 'risk']
    """
    if len(codes) > 10:
        raise HTTPException(400, "最多支持10只股票")

    fields = fields or ['comprehensive', 'news', 'risk']

    # 并行获取所有股票数据
    tasks = []
    for code in codes:
        task = get_single_stock_data(code, fields)
        tasks.append(task)

    results = await asyncio.gather(*tasks, return_exceptions=True)

    return {
        "success": True,
        "data": {
            code: result if not isinstance(result, Exception) else {"error": str(result)}
            for code, result in zip(codes, results)
        }
    }
```

#### 2.2.4 统一缓存层

```python
from functools import lru_cache
from datetime import datetime, timedelta

class DataFlowCache:
    """统一缓存管理"""

    def __init__(self):
        self._cache = {}
        self._ttl = {
            'comprehensive': 300,  # 5分钟
            'news': 300,
            'risk': 600,
            'sentiment': 300
        }

    def get(self, key: str, data_type: str):
        if key not in self._cache:
            return None

        entry = self._cache[key]
        ttl = self._ttl.get(data_type, 300)

        if (datetime.now() - entry['time']).total_seconds() > ttl:
            del self._cache[key]
            return None

        return entry['data']

    def set(self, key: str, data: Any, data_type: str):
        self._cache[key] = {
            'data': data,
            'time': datetime.now(),
            'type': data_type
        }

    def invalidate(self, pattern: str):
        """使匹配的缓存失效"""
        keys_to_delete = [k for k in self._cache if pattern in k]
        for k in keys_to_delete:
            del self._cache[k]

# 全局缓存实例
dataflow_cache = DataFlowCache()
```

---

## 3. 实施计划

### 第一阶段：前端优化（1-2天）

| 任务 | 优先级 | 预计时间 |
|------|--------|----------|
| 并行请求改造 | P0 | 2小时 |
| 请求取消机制 | P0 | 2小时 |
| 分阶段加载 | P1 | 2小时 |
| 防抖节流 | P1 | 1小时 |
| 加载状态细分 | P2 | 1小时 |

### 第二阶段：后端优化（2-3天）

| 任务 | 优先级 | 预计时间 |
|------|--------|----------|
| 综合数据并行化 | P0 | 4小时 |
| 合并新闻+情绪接口 | P0 | 2小时 |
| 批量接口 | P1 | 3小时 |
| 统一缓存层 | P1 | 3小时 |
| 数据源检测优化 | P2 | 2小时 |

### 第三阶段：测试优化（1天）

| 任务 | 优先级 | 预计时间 |
|------|--------|----------|
| 性能测试 | P0 | 2小时 |
| 压力测试 | P1 | 2小时 |
| 边界情况处理 | P1 | 2小时 |

---

## 4. 预期效果

| 指标 | 当前 | 优化后 | 提升 |
|------|------|--------|------|
| 单股票数据加载 | 8-15秒 | 2-4秒 | 70%+ |
| 页面首次加载 | 5-10秒 | 2-3秒 | 60%+ |
| 切换股票响应 | 卡顿明显 | 流畅 | - |
| 后端请求数 | 4次/股票 | 2次/股票 | 50% |
| 重复数据获取 | 有 | 无 | - |

---

## 5. 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| 并行请求过多 | 后端压力 | 限制并发数 |
| 缓存不一致 | 数据错误 | 统一缓存管理 |
| 请求取消失败 | 内存泄漏 | 完善错误处理 |
| 接口改动 | 兼容性 | 保留旧接口，渐进迁移 |
